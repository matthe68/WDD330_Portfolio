<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Notes for week 9 reading">
  <link rel="stylesheet" href="../index/css/normalize.css">
  <link rel="stylesheet" href="../index/css/small.css">
  <link rel="stylesheet" href="../index/css/medium.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel&family=Montserrat:wght@100&display=swap" rel="stylesheet">
  <title>Week 10 Notes</title>
</head>

<body>
  <header>
    <h1>
      Matthew B. Christensen
    </h1>
  </header>
  <h2>
    WDD 330: Week 10 Notes
  </h2>
  <hr>
  <h3>
    mdn web docs_: Client-side Validation
  </h3>
  <p>What is form validation? : Form validation is making sure that you are recieving the needed information in the correct form before even attempting to send it to the server. We also do form validation so that we can force our users to be secure and to protect ourselves from sql injection.</p>
  <p>Built in form validation: Required, min/max length, min/max (number), type, and pattern are all built in forms of built-in form validation. Pattern is probably the most useful as you can use regular expressions to make sure that the data is coming in in the correct form and does or doesn't include certain characters in certain orders (think forcing emails/protecting against sql injection, making sure phone numbers are in the correct form). </p>
  <p>":valid": When an element is valid the ":valid" css pseudo-class applies which lets you apply a specific style to all valid elements. If the user tries to send the data, the form will allow it provided you do not have some javascript to stop them from doing so.</p>
  <p>":invalid": When an element is invalid, the element matches the ":invalid" CSS pseudo-class and possibly other pseudo-classes like ":out-of-range" that allow you to style invalid elements as well. If the user tries to send the data the browser will block the attempt.</p>
  <p>Javascript validation: You can use javascript to take control over the look and feel of native error messages or to deal with legacy browsers that do not support HTML's built-in form validation.</p>
  <p>The Constraint Validation API: Button, fieldset, input, output, select, and text area have a set of methods and properties available. Properties: validationMessage: returns a localized message describing the validation constraints that the control doesn't satisfy; validity: returns a "ValidityState" object that contains several properties describing the validity state of the element; willValidate: returns true if the element will be validated when the form is submitted, false otherwise. The API also makes the following methods available: checkValidity(): returns true if the elements value has no validity problems, false otherwise; reportValidity(): reports invalid fields using events which is useful in combination with the preventDefault() in an onSubmit event handler; setCustomValidity(message): Adds a custom error message to the element; if you set a custom error message, the element is considered to be invalid and the specified error is displayed. </p>
  
  <h3>mdn web docs_: Using the Fetch API</h3>
  <p>I think we've been through the fetch api about 3 times already and I use this every day. The basic rundown is that you do a fetch('website-goes-here').then(response=>response.doSomethingWithIt()).then(do-as-many-or-as-few-of-these-as-you-want);</p>
  <p>Supplying request options: an optional second parameter to the fetch is to put in an object with init parameters. This can include the method (usually GET, POST, PUT, DELETE), mode, cache, headers, redirect, referrerPolicy, body</p>
  <p>Sending a request with credentials: fetch('website, {credentials: 'include'});</p>
  <p>Uploading JSON data: used quite frequently to send information, you can use "fetch('website', {method: 'POST', headers: {Any headers}, body: JSON.stringify(jsonData)});</p>
  <p>Uploading a file: Files can be uploaded using an HTML input type="file" element, input element, formData(), and fetch(). In the fetch you cna then put 'body: formData' where the formData is 'const formData = new FormData()" type. Multiple files can be used the same way as long as input type of the file has the element '[multiple]' and each file is appended to the formData. Attatching the formData in the same way will upload all files at the same time. </p>
  <p>Read through text file line by line: This one is similar to concepts that I know, but you can read through a response file line by line by using "getReader". So response.body.getReader();. Then you can do something like, "let { value: chunk, done: readerDone } = await reader.read();
    chunk = chunk ? utf8Decoder.decode(chunk) : ''; See <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">https://developer.mozilla.org/</a> for more information. 
  </p>
  <p>Checking that the fetch was successful: use .catch(error=>... Checking Response.ok will tell you if it was ok, if not you can use the catch error method to decide what to do with the error.</p>
  <p>Supplying your own request object: Instead of passing a path to the resource you want to request into the fetch() call, you can create a request object using the "Request()" constructor and pass the request in to the fetch instead.</p>
  <p>Headers: You can use an object "Headers()" and then append headers to it. This can be nice to make sure that you are receiving the correct headers back on the response.  </p>
  <p>Response Objects: Response objects are returned when fetch() promises are resolved. Use the status, statusText, and ok properties. </p>



  <footer>
    &copy;2022 | Matthew B. Christensen | Utah
    <div id="last-updated"></div>
  </footer>
  <script src="../index/js/last-updated.js"></script>
</body>
</html>